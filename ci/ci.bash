
tweak_tree_before_configure() { : ; }

step_configure() {
    # now that we're confident that we've made the bwc checks specific to
    # a "with_sagemath" suffix, there's no risk in missing the sagemath
    # code by inadvertence.
    # if [ "$specific_checks" = "bwc.sagemath" ] ; then
    #     export FORCE_BWC_EXTERNAL_CHECKS_OUTPUT_ON_FD3=1
    # fi
    if [ "$specific_checks" = "including_mpi" ] ; then
        export MPI=1
        # sigh. when we run in containers, running as root isn't much of
        # a problem
        export OMPI_ALLOW_RUN_AS_ROOT=1
        export OMPI_ALLOW_RUN_AS_ROOT_CONFIRM=1
    elif [ "$specific_checks" = "only_mpi" ] ; then
        export MPI=1
        # sigh. when we run in containers, running as root isn't much of
        # a problem
        export OMPI_ALLOW_RUN_AS_ROOT=1
        export OMPI_ALLOW_RUN_AS_ROOT_CONFIRM=1
    fi
    if [ "$using_cmake_directly" ] ; then
        (cd "$build_tree" ; cmake "$source_tree")
    else
        "${MAKE}" cmake
    fi
    eval `${MAKE} show`
}

build_steps="build1 build2"
build_step_name_build1="Building"

step_build1() {
    target=all
    if [ "$specific_checks" = "bwc.sagemath" ] ; then
        target=all_sagemath_test_dependencies
    fi
    if [ "$using_cmake_directly" ] ; then
        SOURCEDIR="$PWD"
        (cd "$build_tree" ; "${MAKE}" -j$NCPUS $target)
    else
        "${MAKE}" -j$NCPUS $target
    fi
}

build_step_name_build2="Building test dependencies"
step_build2() {
    target=all_test_dependencies
    if [ "$specific_checks" = "bwc.sagemath" ] ; then
        # already covered in build1 anyway
        return
    fi
    if [ "$using_cmake_directly" ] ; then
        SOURCEDIR="$PWD"
        (cd "$build_tree" ; "${MAKE}" -j$NCPUS $target)
    else
        "${MAKE}" -j$NCPUS $target
    fi
}

prepare_valgrind_environment() {
    vdir=$PWD/valgrind.$CI_COMMIT_SHORT_SHA-$CI_JOB_ID
    export vdir
    mkdir -p $vdir
    cat > $vdir/v.sh <<EOF
#!/usr/bin/env bash
cado=$PWD
vdir=$vdir
EOF
    cat >> $vdir/v.sh <<'EOF'
if [ -x "./$1" ] ; then
    prg="$1"
    shift
    args=("./$prg" "$@")
    set -- "${args[@]}"
fi

# Don't use --error-exitcode, so that we get a chance to be notified of all potential errors at once.
valgrind --suppressions=$cado/cado-nfs.supp --gen-suppressions=all --trace-children=yes --trace-children-skip=gzip,libtool,gcc,g++ "--log-file=$vdir/pid-%p" --leak-check=full "$@"
EOF

    VALGRIND="$vdir/v.sh"
    chmod 755 $VALGRIND

    export PYTHONDONTWRITEBYTECODE=1
    test_precommand+=(env TEST_PRECOMMAND=$VALGRIND)
    # valgrind tests can take _ages_ if we run them with openmp
    export OMP_NUM_THREADS=1
}


check_environment() {
    export OMP_DYNAMIC=true
    # See https://stackoverflow.com/questions/70126350/openmp-incredibly-slow-when-another-process-is-running
    # It's not totally clear to me if it somewhere specified that
    # lowercase "passive" implies GOMP_SPINCOUNT=0 for gcc. If it's not
    # specified, it may change in the future, so let's force the setting
    # ourselves.
    export OMP_DISPLAY_ENV=verbose
    export OMP_WAIT_POLICY=passive
    export GOMP_SPINCOUNT=0
    # OMP_PROC_BIND helps in certain cases, and is a disaster in other
    # cases. We can't afford it.
    # export OMP_PROC_BIND=true
    export STATS_PARSING_ERRORS_ARE_FATAL=1

    test_precommand=()
    if [ "$valgrind" ] ; then
        prepare_valgrind_environment
    fi
    
}


step_coverage() {
    # This takes a coverage file prefix as $1, and info for the kind of
    # file (whether it's "base" or "app", for instance) in $2.
   
    # build_tree and source_tree are used

    outfile="$source_tree/$1-$2.json"

    # Rationale for having this "base" coverage step (and I'm not sure it
    # is still relevant):
    # The "base" coverage file has zero coverage for every instrumented
    # line of the project. At a later stage, we will combine this data
    # file with coverage data files captured after the test run. This way
    # the percentage of total lines covered will always be correct, even
    # when not all source code files were loaded during the test(s).

    # might be useful. We don't want to bother with traces of config
    # checks.
    find "$build_tree" -name '*conftest.gcno' -o -name 'CMake*.gcno' -o -name '?-CMake*.gcno' | xargs -r rm -v

    # ci/ci/001-environment.sh sets build_tree to "./generated" for coverage
    # jobs. Therefore, all files, gcno and gcda, are found under
    # $PWD==$src_tree .
    # This is done so because we have to ship the files that are
    # generated by the build process, and expose them to the merged
    # coverage report.
    # If $build_tree is outside $src_tree, we should add "." before
    # --json
    (set -x ; cd "$build_tree" ; time gcovr --merge-mode-functions=separate -r "$source_tree" --json "$outfile")
}

step_coverage_more_artifacts() {
    prefix="$1"
    if [ "$build_tree" != generated ] ; then
        fatal_error "This part of the script assumes that build_tree=generated"
    fi

    # because of /bin/sh, we can't do arrays.
    find "$build_tree" -name '*.[ch]' -o -name '*.[ch]pp' | xargs -x tar czf ${prefix}-generated-sources.tar.gz
}


coverage_expunge_paths="utils/embedded:gf2x:generated:linalg/bwc/flint-fft:linalg/bwc/mpfq"

dispatch_valgrind_files() {
    cd $vdir
    mkdir ok ok-signal nok system
    find . -type f -a -name 'pid-*' | xargs egrep -l "Command: (/usr/bin|/bin|python|perl|env|[^ ]*\.sh)" | xargs -r mv --target-directory system
    # the rm -rf step could be considered an option
    rm -rf system
    # SEGV is something to worry about, but there are cases where we
    # terminate with SIGTERM / SIGINT / SIGHUP and this is just normal
    # business (e.g., cado-nfs-client.py can do that). It is possible
    # that vlagrind report leaks in such cases, but we're not super
    # interested in them
    ls | grep pid | xargs -r egrep -l 'ERROR SUMMARY: 0' | xargs -r mv -t ok
    ls | grep pid | xargs -r egrep -l 'Process terminating.*signal.*SIG(TERM|INT|HUP)' pid-* | xargs -r mv -t ok-signal
    ls | grep pid | xargs -r egrep -l 'ERROR SUMMARY: [^0]' pid-* | xargs -r mv -t nok
}

postprocess_valgrind() {
    (dispatch_valgrind_files)

    set +e
    nok_files=($(find "$vdir/nok" -type f))
    ok_files=($(find "$vdir/ok" -type f))
    ok_signal_files=($(find "$vdir/ok-signal" -type f))
    set -e

    if [ ${#nok_files[@]} -gt 0 ] ; then
        red_message "Found valgrind errors (${#nok_files[@]} different executions)" >&2
    fi

    for f in "${nok_files[@]}" ; do
        cmd=$(perl -ne 'm{Command: \S*/([^/\s]+)} && print "$1\n";' "$f")
        nerr=$(perl -ne 'm{ERROR SUMMARY: (\d+) errors from (\d+) contexts} && print "$1 from $2\n";' "$f")
        enter_section collapsed errors "Errors in $cmd ($nerr)"
        cat "$f"
        leave_section
    done
    tar czf $vdir.tar.gz $vdir/
    rm -rf $vdir
    if [ $rc != 0 ] ; then
        red_message "exit code was $rc" >&2
        exit $rc
    fi
    if [ ${#nok_files[@]} -gt 0 ] ; then
        fatal_error "Found valgrind errors (${#nok_files[@]} different executions)" "See archive of log files in $vdir.tar.gz" 
    else
        green_message "valgrind passed successfully (${#ok_files[@]} different executions)"
        if [ "${#ok_signal_files[@]}" ] ; then
            yellow_message "NOTE: valgrind reported (possibly spurious) errors on ${#ok_signal_files[@]} executions that were terminated by SIG{TERM,INT,HUP}"
        fi
        green_message "See archive of log files in $vdir.tar.gz"
    fi
}

step_check() {
    # --no-compress-output is perhaps better for test uploading, as ctest
    # likes to store as zlib but headerless, which is a bit of a pain

    ctest_args="-T Test --no-compress-output --test-output-size-passed 4096 --test-output-size-failed 262144"

    if [ "$specific_checks" = "bwc.sagemath" ] ; then
        ctest_args="$ctest_args -R with_sagemath"
    elif [ "$specific_checks" = "including_mpi" ] ; then
        # nothing to do
        :
    elif [ "$specific_checks" = "only_mpi" ] ; then
        ctest_args="$ctest_args -R mpi"
    fi

    if [ "$using_cmake_directly" ] ; then
        set -o pipefail
        (cd "$build_tree" ; "${test_precommand[@]}" ctest -j$NCPUS $ctest_args ) | "$source_tree"/scripts/filter-ctest.pl
    else
        "${test_precommand[@]}" "${MAKE}" check ARGS="-j$NCPUS $ctest_args"
    fi
    rc=$?
    export rc

    if [ "$valgrind" ] ; then
        (set +x ; postprocess_valgrind)
    else
        return $rc
    fi
}

step_doc() { : ; }
