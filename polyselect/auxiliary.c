/* Auxiliary routines for polynomial selection

Copyright 2008-2017 Emmanuel Thome, Paul Zimmermann

This file is part of CADO-NFS.

CADO-NFS is free software; you can redistribute it and/or modify it under the
terms of the GNU Lesser General Public License as published by the Free
Software Foundation; either version 2.1 of the License, or (at your option)
any later version.

CADO-NFS is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more
details.

You should have received a copy of the GNU Lesser General Public License
along with CADO-NFS; see the file COPYING.  If not, write to the Free Software
Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
*/

#include "cado.h" // IWYU pragma: keep
#include <stdio.h>
#include <stdlib.h>
#include <float.h> // for DBL_MAX
#include <math.h>
#include <gmp.h>

#include "mpz_poly.h"
#include "cado_poly.h"
#include "auxiliary.h"
#include "macros.h" /* for ASSERT_ALWAYS */
#include "murphyE.h"
#include "timing.h"             // for seconds
#include "version_info.h"        // cado_revision_string
#include "polyselect_norms.h"
#include "polyselect_alpha.h"

/**************************** rotation ***************************************/

/* replace f + k0 * x^t * g by f + k * x^t * g, and return k */
long
rotate_aux (mpz_poly_ptr f, mpz_poly_srcptr g, long k0, long k, unsigned int t)
{
  /* Warning: k - k0 might not be representable in a long! */
  if (k > k0) {
      mpz_poly_rotation_ui(f, f, g, k - k0, t);
  } else if (k < k0) {
      mpz_poly_reverse_rotation_ui(f, f, g, k0 - k, t);
  }
  return k;
}

/* replace f by f + k * x^t * (b*x + g0) */
void
rotate_auxg_z (mpz_poly_ptr f, mpz_poly_srcptr g, mpz_srcptr k, unsigned int t)
{
    mpz_poly_rotation(f, f, g, k, t);
}

/*
   Print f, g only.
   Note: it's a backend for print_cadopoly().
*/
void
print_cadopoly_fg (FILE *fp, mpz_poly_srcptr f, mpz_poly_srcptr g, mpz_srcptr n)
{
   int i;

   /* n */
   gmp_fprintf (fp, "\nn: %Zd\n", n);

   /* Y[i] */
   for (i = g->deg; i >= 0; i--)
     gmp_fprintf (fp, "Y%d: %Zd\n", i, mpz_poly_coeff_const(g, i));

   /* c[i] */
   for (i = f->deg; i >= 0; i--)
     gmp_fprintf (fp, "c%d: %Zd\n", i, mpz_poly_coeff_const(f, i));
}


/*
   Print f, g only, lognorm, skew, alpha, MurphyE.
   Note:  it's a backend for print_cadopoly_extra().
*/
double
print_cadopoly (FILE *fp, cado_poly_srcptr cpoly)
{
   mpz_poly_srcptr F = cpoly->pols[ALG_SIDE];
   mpz_poly_srcptr G = cpoly->pols[RAT_SIDE];

   /* print f, g only*/
   print_cadopoly_fg (fp, F, G, cpoly->n);

   fprintf (fp, "skew: %1.3f\n", cpoly->skew);

   cado_poly_stats spoly;
   cado_poly_stats_init(spoly, 2);
   cado_poly_compute_stats(spoly, cpoly);
   cado_poly_fprintf_stats(fp, NULL, cpoly, spoly);
   cado_poly_stats_clear(spoly);

   int alpha_bound = get_alpha_bound ();

   double avg_e = 0;
   int nalg = 0;
   for(int side = 0 ; side < cpoly->nb_polys ; side++) {
       if (mpz_poly_degree(cpoly->pols[side]) == 1) continue;
       double e = MurphyE (cpoly, bound_f, bound_g, area, MURPHY_K, alpha_bound);
       avg_e += e;
       nalg++;
       cado_poly_fprintf_MurphyE (fp, "", side, e, bound_f, bound_g, area);
   }

   return avg_e / nalg;
}


/*
   Print f, g, lognorm, skew, alpha, MurphyE, REV, time duration.
*/
void
print_cadopoly_extra (FILE *fp, cado_poly cpoly, int argc, char const * argv[], double st)
{
   int i;

   print_cadopoly (fp, cpoly);
   /* extra info */
   fprintf (fp, "# generated by %s: %s", cado_revision_string, argv[0]);
   for (i = 1; i < argc; i++)
      fprintf (fp, " %s", argv[i]);
   fprintf (fp, " in %.2fs\n", (seconds () - st));
}


/*
 * Call print_cadopoly, given f, g and return MurphyE.
 */
double
print_poly_fg (mpz_poly_srcptr f, mpz_poly_srcptr g, mpz_srcptr N, int mode)
{
   double e;

   cado_poly cpoly;
   cado_poly_init (cpoly);
   cado_poly_provision_new_poly(cpoly);
   cado_poly_provision_new_poly(cpoly);
   mpz_poly_set(cpoly->pols[ALG_SIDE], f);
   mpz_poly_set(cpoly->pols[RAT_SIDE], g);
   mpz_set(cpoly->n, N);
   cado_poly_set_skewness_if_undefined(cpoly);

   if (mode == 1)
     {
       e = print_cadopoly (stdout, cpoly);
       fflush(stdout);
     }
   else
     e = MurphyE (cpoly, bound_f, bound_g, area, MURPHY_K, get_alpha_bound ());

   cado_poly_clear (cpoly);
   return e;
}


/* TODO: Does it make sense with multiple polynomials?
 */
void cado_poly_set_skewness_if_undefined(cado_poly_ptr cpoly)
{
    if (cpoly->skew <= 0.0) /* If skew is undefined, compute it. */
        cpoly->skew = L2_combined_skewness2 (cpoly->pols[RAT_SIDE], cpoly->pols[ALG_SIDE]);
}

void cado_poly_stats_init(cado_poly_stats_ptr spoly, int nb_polys)
{
    spoly->nb_polys = nb_polys;
    spoly->pols = malloc(spoly->nb_polys * sizeof(*spoly->pols));
    for(int side = 0 ; side < nb_polys ; side++) {
            spoly->pols[side]->nrroots = 0;
            spoly->pols[side]->lognorm = 0;
            spoly->pols[side]->alpha = 0;
            spoly->pols[side]->alpha_proj = 0;
            spoly->pols[side]->exp_E = 0;
    }
}

void cado_poly_stats_clear(cado_poly_stats_ptr spoly)
{
    free(spoly->pols);
}

/* This is only valid for a poly pair that comes right from the first
 * stage of polyselect.
 *
 * The average of the exp_E values for the algebraic polynomial(s) is
 * returned.
 */
double cado_poly_compute_expected_stats(cado_poly_stats_ptr spoly, cado_poly_srcptr cpoly)
{
    ASSERT_ALWAYS(cpoly->skew > 0);
    ASSERT_ALWAYS(mpz_poly_degree(cpoly->pols[RAT_SIDE]) == 1);

    /* Use the routine for the "final" stats, which actually computes
     * fewer things */
    cado_poly_compute_stats(spoly, cpoly);
    double avg_E = 0;
    int nalg = 0;
    for(int side = 0 ; side < cpoly->nb_polys ; side++) {
        if (mpz_poly_degree(cpoly->pols[side]) > 1) {
            spoly->pols[side]->exp_E = spoly->pols[side]->lognorm +
                + expected_rotation_gain (cpoly->pols[side], cpoly->pols[RAT_SIDE]);
            avg_E += spoly->pols[side]->exp_E;
            nalg++;
        }
    }
    return avg_E / nalg;
}

double cado_poly_compute_stats(cado_poly_stats_ptr spoly, cado_poly_srcptr cpoly)
{
    ASSERT_ALWAYS(cpoly->skew > 0);
    ASSERT_ALWAYS(mpz_poly_degree(cpoly->pols[RAT_SIDE]) == 1);
    double avg_E = 0;
    int nalg = 0;
    for(int side = 0 ; side < cpoly->nb_polys ; side++) {
        if (mpz_poly_degree(cpoly->pols[side]) == 1) {
            spoly->pols[side]->nrroots = 0;
            spoly->pols[side]->lognorm = 0;
            spoly->pols[side]->alpha = 0;
            spoly->pols[side]->alpha_proj = 0;
            spoly->pols[side]->exp_E = 0;
        } else {
            spoly->pols[side]->nrroots = mpz_poly_number_of_real_roots(cpoly->pols[side]);
            spoly->pols[side]->lognorm = L2_lognorm (cpoly->pols[side], cpoly->skew);
            spoly->pols[side]->alpha = get_alpha (cpoly->pols[side], get_alpha_bound ());
            spoly->pols[side]->alpha_proj = get_alpha_projective (cpoly->pols[side], get_alpha_bound ());
            spoly->pols[side]->exp_E = 0;
            avg_E += spoly->pols[side]->lognorm + spoly->pols[side]->alpha;
            nalg++;
        }
    }
    return avg_E / nalg;
}

void cado_poly_fprintf_stats(FILE * fp, const char * prefix, cado_poly_srcptr cpoly, cado_poly_stats_srcptr spoly)
{
    ASSERT_ALWAYS(cpoly->skew > 0);
    for(int side = 0 ; side < cpoly->nb_polys ; side++) {
        if (mpz_poly_degree(cpoly->pols[side]) == 1)
            continue;
        fprintf (fp, "%s# side %d lognorm %1.2f, %s %1.2f, alpha %1.2f (proj %1.2f),"
                " %u real root%s\n",
                prefix ? prefix : "", side,
                spoly->pols[side]->lognorm,
                spoly->pols[side]->exp_E <= 0 ? "E" : "exp_E",
                spoly->pols[side]->exp_E <= 0 ? (spoly->pols[side]->lognorm + spoly->pols[side]->alpha) : spoly->pols[side]->exp_E,
                spoly->pols[side]->alpha,
                spoly->pols[side]->alpha_proj,
                spoly->pols[side]->nrroots,
                (spoly->pols[side]->nrroots <= 1) ? "" : "s");
    }
}

/* compute largest interval kmin <= k <= kmax such that when we add k*x^i*g(x)
   to f(x), the lognorm does not exceed maxlognorm (with skewness s) */
void
expected_growth (rotation_space *r, mpz_poly_srcptr f0, mpz_poly_srcptr g, int i,
                 double maxlognorm, double s)
{
  mpz_t kmin, kmax, k;
  double n2;

  mpz_poly f;
  mpz_poly_init(f, -1);
  mpz_poly_set(f, f0);

  mpz_init (kmin);
  mpz_init (kmax);
  mpz_init (k);

  /* negative side */
  mpz_set_si (kmin, -1);
  for (;;)
    {
      mpz_poly_rotation(f, f0, g, kmin, i);
      n2 = L2_lognorm (f, s);
      if (n2 > maxlognorm)
        break;
      mpz_mul_2exp (kmin, kmin, 1);
    }
  /* now kmin < k < kmin/2 */
  mpz_tdiv_q_2exp (kmax, kmin, 1);
  while (1)
    {
      mpz_add (k, kmin, kmax);
      mpz_div_2exp (k, k, 1);
      if (mpz_cmp (k, kmin) == 0 || mpz_cmp (k, kmax) == 0)
        break;
      mpz_poly_rotation(f, f0, g, k, i);
      n2 = L2_lognorm (f, s);
      if (n2 > maxlognorm)
        mpz_set (kmin, k);
      else
        mpz_set (kmax, k);
    }
  r->kmin = mpz_get_d (kmax);

  /* positive side */
  mpz_set_ui (kmax, 1);
  for (;;)
    {
      mpz_poly_rotation(f, f0, g, kmax, i);
      n2 = L2_lognorm (f, s);
      if (n2 > maxlognorm)
        break;
      mpz_mul_2exp (kmax, kmax, 1);
    }
  /* now kmax < k < kmax/2 */
  mpz_tdiv_q_2exp (kmin, kmax, 1);
  while (1)
    {
      mpz_add (k, kmin, kmax);
      mpz_div_2exp (k, k, 1);
      if (mpz_cmp (k, kmin) == 0 || mpz_cmp (k, kmax) == 0)
        break;
      mpz_poly_rotation(f, f0, g, k, i);
      n2 = L2_lognorm (f, s);
      if (n2 > maxlognorm)
        mpz_set (kmax, k);
      else
        mpz_set (kmin, k);
    }
  r->kmax = mpz_get_d (kmin);

  mpz_poly_clear(f);

  mpz_clear (kmin);
  mpz_clear (kmax);
  mpz_clear (k);
}

/* for a given pair (f,g), tries to estimate the value of alpha one might
   expect from rotation (including the projective alpha) */
double
expected_rotation_gain (mpz_poly_srcptr f, mpz_poly_srcptr g)
{
  double S = 1.0, s, incr = 0.0;
  rotation_space r;
  double proj_alpha = get_alpha_projective (f, ALPHA_BOUND_SMALL);
  double skew = L2_skewness (f);
  double n = L2_lognorm (f, skew);

  for (int i = 0; 2 * i < f->deg; i++)
    {
      expected_growth (&r, f, g, i, n + NORM_MARGIN, skew);
      s = r.kmax - r.kmin + 1.0;
      S *= s;
      /* assume each non-zero rotation increases on average by NORM_MARGIN/2 */
      if (s >= 2.0)
        incr += NORM_MARGIN / 2.0;
    }
  return proj_alpha + expected_alpha (log(S)) + incr;
}

