#ifndef CADO_UTILS_NUMBERTHEORY_NUMBER_FIELD_HPP
#define CADO_UTILS_NUMBERTHEORY_NUMBER_FIELD_HPP

#include <memory>
#include <string>
#include <ostream>

#include "fmt/base.h"
#include "fmt/format.h"

#include "numbertheory/numbertheory_fwd_types.hpp"
#include "fmt_helper_sagemath.hpp"
#include "cxx_mpz.hpp"
#include "mpz_poly.h"
#include "mpz_mat.h"

class number_field_element;

class number_field {
    cxx_mpz_poly f;
    cxx_mpz_poly f_hat;
    mutable std::unique_ptr<number_field_order> cached_maximal_order;
    mutable std::unique_ptr<cxx_mpq_mat> cached_trace_matrix;
    mutable std::unique_ptr<std::pair<unsigned int, unsigned int>> cached_signature;
    public:
    std::string name, varname;
    explicit number_field(cxx_mpz_poly const& f);
    cxx_mpz_poly const& defining_polynomial() const { return f; }
    int degree() const { return defining_polynomial().degree(); }
    std::pair<unsigned int, unsigned int> signature() const;
    unsigned int unit_rank() const {
        auto rs = signature();
        return rs.first + rs.second - 1;
    }
    number_field_element gen() const;
    number_field_element operator()(cxx_mpz_poly const &, cxx_mpz const & =1) const;
    number_field_element operator()(cxx_mpz_mat const &, cxx_mpz const & =1) const;
    number_field_element operator()(cxx_mpq_mat const &) const;
    void bless(const char * name, const char * varname = nullptr);
    void bless(std::string const & name, std::string const & varname);
    void bless(std::string const & name);
    number_field_order equation_order() const;
    number_field_order p_maximal_order(cxx_mpz const & p) const;

    /* return the order generated by this element, which must be integral */
    number_field_order order(number_field_element const & a) const;

    number_field_order const& maximal_order(unsigned long prime_limit=0) const;
    cxx_mpq_mat trace_matrix() const;

    /* convert an element of an order to the equivalent element as an
     * element of the number field */
    number_field_element operator()(number_field_order_element const &) const;

    cxx_mpq_mat basis_matrix_from_f_to_monic(cxx_mpq_mat const & B) const;
    cxx_mpq_mat basis_matrix_from_monic_to_f(cxx_mpq_mat const & B) const;
};

namespace fmt {
    template <>
    struct formatter<number_field>
        : fmt_helper_sagemath<number_field>
    {
        static constexpr const decltype(custom_format) custom_format_default = TEXT;
        auto format(number_field const & K, format_context& ctx) const -> format_context::iterator;
    };
} /* namespace fmt */
inline std::ostream& operator<<(std::ostream& os, number_field const & K) { return os << fmt::format("{}", K); }


#endif	/* UTILS_NUMBERTHEORY_NUMBER_FIELD_HPP_ */
