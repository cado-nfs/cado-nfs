#ifndef CADO_UTILS_NUMBERTHEORY_NUMBER_FIELD_FRACTIONAL_IDEAL_HPP
#define CADO_UTILS_NUMBERTHEORY_NUMBER_FIELD_FRACTIONAL_IDEAL_HPP

#include <memory>
#include <utility>
#include <vector>
#include <ostream>

#include <gmp.h>
#include "fmt/base.h"
#include "fmt/format.h"

#include "numbertheory/numbertheory_fwd_types.hpp"
#include "numbertheory/number_field_order.hpp"
#include "cxx_mpz.hpp"
#include "macros.h"
#include "mpz_mat.h"


class number_field_fractional_ideal {
    friend struct fmt::formatter<number_field_fractional_ideal>;
    friend class number_field_order;
    friend class number_field_prime_ideal;
    number_field_order const & O;
    /* the basis matrix is in HNF form, with respect to the basis of the
     * order */
    cxx_mpz_mat ideal_basis_matrix;
    cxx_mpz denominator;
    public:
    /* oddly enough, we have no code for 2-element except for prime
     * ideals. Should we do it just by CRT? It's an option, but we don't
     * have much need for it, really.
     */
    typedef std::pair<cxx_mpz, number_field_order_element> two_element;
    private:
    mutable std::unique_ptr<two_element> cached_two_element;
    number_field_fractional_ideal(number_field_order const & O,
            cxx_mpz_mat I,
            cxx_mpz d = 1)
        : O(O)
        , ideal_basis_matrix(std::move(I))
        , denominator(std::move(d))
    {}
    public:

    /* return the order this ideal is defined to be a fractional ideal
     * of. Note that the actual endomorphism ring of the ideal may of
     * course be bigger!
     */
    number_field_order const & order() const { return O; }

    /* return the parent number field */
    class number_field const & number_field() const { return O.number_field(); }

    bool is_integral() const { return denominator == 1; }

    // unimplemented (for now)
    // operator two_element() const;

    /* return the fractional O-ideal generated by the given generators
     */
    number_field_fractional_ideal(number_field_order const & O, std::vector<number_field_element> const & gens);

    /* return the valuation at the given prime ideal
     */
    int valuation(number_field_prime_ideal const & fkp) const;

    number_field_fractional_ideal(number_field_fractional_ideal const & a)
        : O(a.O)
        , ideal_basis_matrix(a.ideal_basis_matrix)
        , denominator(a.denominator)
    {}

    number_field_fractional_ideal(number_field_fractional_ideal && a) noexcept
        : O(a.O)
        , ideal_basis_matrix(std::move(a.ideal_basis_matrix))
        , denominator(std::move(a.denominator))
    {}

    number_field_fractional_ideal& operator=(number_field_fractional_ideal const & a)
    {
        ASSERT_ALWAYS(&O == &a.O);
        if (this != &a) {
            ideal_basis_matrix = a.ideal_basis_matrix;
            denominator = a.denominator;
        }
        return *this;
    }
    number_field_fractional_ideal& operator=(number_field_fractional_ideal && a)
    {
        ASSERT_ALWAYS(&O == &a.O);
        ideal_basis_matrix = std::move(a.ideal_basis_matrix);
        denominator = std::move(a.denominator);
        return *this;
    }

    int cmp(number_field_fractional_ideal const & I) const {
        int const r = mpz_cmp(denominator, I.denominator);
        if (r) return r;

        /* XXX this is only correct if we assume that both basis matrices
         * are in HNF. Otherwise we would have to check 
         * equivalence modulo SL_n !
         */
        return mpz_mat_cmp(ideal_basis_matrix, I.ideal_basis_matrix);
    }

    bool operator<(number_field_fractional_ideal const & I) const {
        return cmp(I) < 0;
    }
};

namespace fmt {
    template <> struct formatter<number_field_fractional_ideal> : formatter<string_view>{
        auto format(number_field_fractional_ideal const & e, format_context& ctx) const -> format_context::iterator;
    };
}
inline std::ostream& operator<<(std::ostream& os, number_field_fractional_ideal const & e) { return os << fmt::format("{}", e); }
#endif	/* UTILS_NUMBERTHEORY_NUMBER_FIELD_FRACTIONAL_IDEAL_HPP_ */
