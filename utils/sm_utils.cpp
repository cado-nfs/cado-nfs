#include "cado.h" // IWYU pragma: keep

#define xxxxWIP_SM

#include <cstdint>
#include <cstdio>  // FILE
#include <cstdlib> // free, malloc, abort
#include <cstring> // strcmp memset

#include <vector>

#ifdef WIP_SM
#include "fmt/base.h"
#endif
#include <gmp.h>

#include "cxx_mpz.hpp"
#include "gmp_aux.h"
#include "macros.h" // for ASSERT_ALWAYS
#include "mpz_mat.h"
#include "mpz_poly.h" // mpz_poly
#include "numbertheory.hpp"
#include "sm_utils.hpp"

/* u and dst may be equal */
void sm_side_info::compute_piecewise(cxx_mpz_poly & dst,
                                     cxx_mpz_poly const & u) const
{
    /* now for a split-chunk compute_sm */

    if (nsm == 0)
        return;

    int const n = f0->deg;
    mpz_poly_realloc(dst, n);

    cxx_mpz_poly temp;

    std::vector<cxx_mpz_poly> chunks(pieces.size());

    int s = 0;
    for (size_t j = 0; j < pieces.size(); j++) {
        if (!pieces[j].is_used)
            continue;
        /* it is tempting to reduce u mod g ; depending on the context,
         * it may even be a good idea. However, doing so automatically is
         * wrong, since this function may also be called with tiny data
         * such as a-bx ; there, multiplying by a-bx with word-size a and
         * b is better than multiplying by a-bx mod g, which may be a
         * much longer integer (in the case deg(g)=1 ; otherwise reducing
         * is a noop in such a case).
         */
#if 0
        if (g->deg > 1) {
            compute_sm_lowlevel (chunks[j], u,
                    g, ell, exponents[j], ell2);
        } else {
            ASSERT_ALWAYS(mpz_cmp_ui(mpz_poly_coeff_const(g, 1), 1) == 0);
            mpz_poly_set(chunks[j], u);
            mpz_poly_mod_f_mod_mpz(chunks[j], g, ell2, nullptr, nullptr);
            ASSERT_ALWAYS(chunks[j]->deg == 0);
            mpz_ptr c = mpz_poly_coeff(chunks[j], 0);
            mpz_powm(c, c, exponents[j], ell2);
            mpz_sub_ui(c, c, 1);
            mpz_divexact(c, c, ell);
        }
#else
        cxx_mpz_poly & SM(chunks[j]);

        mpz_poly_pow_mod_f_mod_mpz(SM, u, pieces[j].g, pieces[j].exponent,
                                   ell2);

        if (SM->deg == -1) {
#ifdef WIP_SM
            fmt::print("{{"
                       "{} has non-zero valuation at ({}, {})"
                       "}}",
                       u, ell, pieces[j].g);
#endif
            /* form the ideal generated by u */
            cxx_mpq_mat gens(1, n);
            for (int i = 0; i < n; i++) {
                mpq_set_z(gens(0, i), mpz_poly_coeff_const(u, i));
            }
            auto I = numbertheory_internals::generate_ideal(O, M, gens);
            /* compute its valuation at the current ideal */
            int const v =
                numbertheory_internals::valuation_of_ideal_at_prime_ideal(
                    M, I, pieces[j].a, 1, ell);
#ifdef WIP_SM
            fmt::print("{{"
                       "{} has valuation exactly {} at ({}, {})."
                       "}}",
                       u, v, ell, pieces[j].g);
#endif

            /* write u as an element of the order */
            cxx_mpz_mat uO;
            cxx_mpz duO;
            {
                cxx_mpq_mat Oi;
                cxx_mpq_mat T;
                mpq_mat_inv(Oi, O);
                mpq_mat_mul(T, gens, Oi);
                mpq_mat_numden(uO, duO, T);
            }

            /*
            cxx_mpz_poly u_fixed = u;
            */

            {
                cxx_mpz_poly kill;
                cxx_mpz dtheta;
                cxx_mpq_mat theta;
                cxx_mpz_mat ntheta;
                mpq_mat_set_mpz_mat(theta, pieces[j].a);
                mpq_mat_mul(theta, theta, O);
                mpq_mat_numden(ntheta, dtheta, theta);
                for (int i = 0; i < n; i++)
                    mpz_poly_setcoeff(kill, i, ntheta(0, i));
                mpz_poly_cleandeg(kill, n - 1);
#ifdef WIP_SM
                fmt::print("{{"
                           "killer is {}/{}"
                           "}}",
                           kill.print_poly("alpha"), dtheta);
#endif
            }

#ifdef WIP_SM
            /* multiply by a^v */
            fmt::print("{{"
                       "{} is {}/{} relative to O"
                       "}}",
                       u, write_order_element_as_vector(uO), duO);
#endif
            for (int w = 0; w < v; w++) {
                uO = numbertheory_internals::multiply_elements_in_order(
                    M, uO, pieces[j].a);
                mpz_mat_divexact_mpz(uO, uO, ell);
#ifdef WIP_SM
                fmt::print("{{"
                           "({})*(a/ell)^{} is {}/{} relative to O"
                           "}}",
                           u, w + 1, write_order_element_as_vector(uO), duO);
#endif
            }

            /* now write u as a polynomial in alpha */
            cxx_mpz_poly u_fixed_poly;
            cxx_mpz u_fixed_den;
            {
                cxx_mpq_mat T(uO);
                cxx_mpz_mat Z;
                mpq_mat_mul(T, T, O);
                mpq_mat_numden(Z, u_fixed_den, T);
                for (int i = 0; i < n; i++)
                    mpz_poly_setcoeff(u_fixed_poly, i, Z(0, i));
            }
            mpz_poly_pow_mod_f_mod_mpz(SM, u_fixed_poly, pieces[j].g,
                                       pieces[j].exponent, ell2);
#ifdef WIP_SM
            fmt::print("{{"
                       "SM of fixed u is {}"
                       "}}",
                       SM);
#endif
            /* and then we have duO^v * u_fixed_den. We need to deal with
             * them as well... */
        }
        mpz_poly_sub_ui(SM, SM, 1);
        mpz_poly_divexact_mpz(SM, SM, ell);
#endif
        mpz_poly_srcptr g = pieces[j].g;
        for (int k = 0; k < g->deg; k++, s++) {
            if (mode == SM_MODE_2019REV)
                mpz_swap(mpz_poly_coeff(temp, s),
                         mpz_poly_coeff(chunks[j], g->deg - 1 - k));
            else
                mpz_swap(mpz_poly_coeff(temp, s), mpz_poly_coeff(chunks[j], k));
        }
    }

    if (mode == SM_MODE_LEGACY_PRE2018) {
        temp->deg = n - 1;
        /* now apply the change of basis matrix */
        for (int s = 0; s < n; s++) {
            mpz_ptr y = mpz_poly_coeff(dst, s);
            mpz_set_ui(y, 0);
            for (int k = 0; k < n; k++) {
                mpz_addmul(y, mpz_poly_coeff_const(temp, k), matrix(k, s));
            }
            mpz_mod(y, y, ell);
        }
        dst->deg = n - 1;
    } else {
        temp->deg = s - 1;
        mpz_poly_set(dst, temp);
    }
}

void print_sm2(FILE * f, sm_side_info const & S, mpz_poly_srcptr SM,
               char const * delim)
{
    if (S.nsm == 0)
        return;

    for (int j = 0; j < S.nsm; ++j) {

        int const jx = S.mode == SM_MODE_LEGACY_PRE2018 ? S.f->deg - 1 - j : j;

        if (jx > SM->deg)
            fprintf(f, "0");
        else
            gmp_fprintf(f, "%Zu", mpz_poly_coeff_const(SM, jx));

        if (j != S.nsm - 1)
            fputs(delim, f);
    }
}

void print_sm(FILE * f, sm_side_info const & S, mpz_poly_srcptr SM)
{
    print_sm2(f, S, SM, " ");
}

/* Given an array of row indices and an array of abpolys,
 * construct the polynomial that corresponds to the relation-set, i.e.
 *          rel = prod(abpoly[rk]^ek)
 * where rk is the index of a row, ek its exponent
 * and abpoly[rk] = bk*x - ak.
 * rel is built as a fraction (sm_relset_t) and should be initialized.
 */
sm_relset sm_build_one_relset(uint64_t const * r, int64_t const * e, size_t len,
                              std::vector<pair_and_sides> const & ps,
                              std::vector<mpz_poly_srcptr> const & F,
                              mpz_srcptr ell2)
{
    cxx_mpz ee;
    sm_relset rel(F.size());
    std::vector<cxx_mpz_poly> tmp(F.size());

    /* Set the initial fraction to 1 / 1 */
    for (size_t side = 0; side < F.size(); side++) {
        rel.num[side] = 1;
        rel.denom[side] = 1;
    }

    for (size_t k = 0; k < len; k++) {
        /* Should never happen! */
        ASSERT_ALWAYS(e[k] != 0);
        cxx_mpz_poly const & ab = ps[r[k]].ab;
        auto const & si = ps[r[k]].active_sides;

        if (e[k] > 0) {
            mpz_set_si(ee, e[k]);
            /* TODO: mpz_poly_long_power_mod_f_mod_mpz */
            for (auto const s: si) {
                if (F[s] == nullptr)
                    continue;
                mpz_poly_pow_mod_f_mod_mpz(tmp[s], ab, F[s], ee, ell2);
                mpz_poly_mul_mod_f_mod_mpz(rel.num[s], rel.num[s], tmp[s], F[s],
                                           ell2, nullptr, nullptr);
            }
        } else {
            mpz_set_si(ee, -e[k]);
            /* TODO: mpz_poly_long_power_mod_f_mod_mpz */
            for (auto const s: si) {
                if (F[s] == nullptr)
                    continue;
                mpz_poly_pow_mod_f_mod_mpz(tmp[s], ab, F[s], ee, ell2);
                mpz_poly_mul_mod_f_mod_mpz(rel.denom[s], rel.denom[s], tmp[s],
                                           F[s], ell2, nullptr, nullptr);
            }
        }
    }
    return rel;
}

static int compute_unit_rank(mpz_poly_srcptr f)
{
    int const r1 = mpz_poly_number_of_real_roots(f);
    ASSERT_ALWAYS((f->deg - r1) % 2 == 0);
    int const r2 = (f->deg - r1) / 2;
    int const unitrank = r1 + r2 - 1;
    return unitrank;
}

static void
compute_change_of_basis_matrix(cxx_mpz_mat & matrix, mpz_poly_srcptr f,
                               std::vector<sm_side_info::piece> const & pieces,
                               cxx_mpz const & ell)
{
    /* now compute the change of basis matrix. This is given simply
     * as the CRT matrix from the piecewise representation modulo
     * the factors of f to the full representation.
     *
     * We thus have full_repr(x) = \sum multiplier_g * repr_g(x)
     *
     * Where multiplier_g is a multiple of f/g, such that
     * f/g*multiplier_g is one modulo f.
     *
     * Note that the computation of this matrix is ok to do mod ell
     * only ; going to ell^2 is unnecessary.
     */

    int s = 0;
    for (auto const & pf: pieces) {
        cxx_mpz_poly d, a, b, h;
        mpz_poly_srcptr g = pf.g;

        /* compute h = product of other factors */
        mpz_poly_divexact(h, f, g, ell);

        /* now invert h modulo g */

        /* say a*g + b*h = 1 */
        mpz_poly_xgcd_mpz(d, g, h, a, b, ell);

        /* we now have the complete cofactor */
        mpz_poly_mul_mod_f_mod_mpz(h, b, h, f, ell, nullptr, nullptr);
        for (int j = 0; j < g->deg; j++, s++) {
            /* store into the matrix the coefficients of x^j*h
             * modulo f */
            for (int k = 0; k < f->deg; k++) {
                if (k <= h->deg)
                    mpz_set(mpz_mat_entry(matrix, s, k),
                            mpz_poly_coeff_const(h, k));
            }
            mpz_poly_mul_xi(h, h, 1);
            mpz_poly_mod_f_mod_mpz(h, f, ell, nullptr, nullptr);
        }
    }
}

void sm_side_info::print(FILE * out) const
{
    if (unit_rank == 0) {
        fprintf(out, "# unit rank is 0, no SMs to compute\n");
        return;
    }
    fprintf(out, "# unit rank is %d\n", unit_rank);
    fprintf(out, "# lifted factors of f modulo ell^2\n");
    for (size_t i = 0; i < pieces.size(); i++) {
        gmp_fprintf(out, "# factor %d (used=%d), exponent ell^%d-1=%Zd:\n# ", i,
                    pieces[i].is_used, pieces[i].g->deg,
                    (mpz_srcptr)pieces[i].exponent);
        mpz_poly_fprintf(out, pieces[i].g);
    }
    if (mode == SM_MODE_LEGACY_PRE2018) {
        fprintf(out, "# change of basis matrix to OK/ell*OK from piecewise "
                     "representation\n");
        for (int i = 0; i < f->deg; i++) {
            fprintf(out, "# ");
            for (int j = 0; j < f->deg; j++) {
                gmp_fprintf(out, " %Zd", matrix[i * f->deg + j]);
            }
            fprintf(out, "\n");
        }
    }
}

sm_side_info::sm_side_info(mpz_poly_srcptr f0, mpz_srcptr ell,
                           bool handle_small_ell)
    : unit_rank(compute_unit_rank(f0))
    , nsm(unit_rank) /* By default, we compute 'unit_rank' SMs. It can
                        be modify by the user. */

{
    if (unit_rank == 0)
        return;

    mpz_set(this->ell, ell);
    mpz_mul(ell2, ell, ell);
    mpz_mul(ell3, ell2, ell);

    mpz_poly_set(this->f0, f0);

    mpz_poly_makemonic_mod_mpz(f, f0, ell2);

    /* note that sm->exponents is initialized at the very end of this
     * function */

    /* compute the lifted factors of f modulo ell^2 */
    {
        /* polynomial factorization is Las Vegas type */
        cxx_gmp_randstate rstate;
        auto fac = mpz_poly_factor_and_lift_padically(
            f, ell, 2 + handle_small_ell, rstate);
        for (auto const & fm: fac) {
            pieces.emplace_back(fm.first, fm.second, false, 1);
        }
    }

    /* select a subset of factors such that the sum of the degrees is
     * at least the number of sm to compute */
    {
        int s = 0;
        int i = 0;
        while (s < nsm) {
            ASSERT_ALWAYS(pieces.size() > (size_t)i);
            s += pieces[i].g->deg;
            pieces[i].is_used = true;
            i++;
        }
        i--;
        while (s > nsm && i >= 0) {
            int const di = pieces[i].g->deg;
            if (s - di >= nsm) {
                s -= di;
                pieces[i].is_used = false;
            }
            i--;
        }
    }

    /* also compute the lcm of the ell^i-1 ; note that it's only used in
     * the legacy case, afaik. */
    exponent = 1;

    for (auto & P: pieces) {
        mpz_pow_ui(P.exponent, ell, P.g->deg);
        mpz_sub_ui(P.exponent, P.exponent, 1);
        mpz_lcm(exponent, exponent, P.exponent);
    }

    /* We need to compute an ell-maximal order. Well, most probably
     * Z[\alpha\hat] is an ell-maximal order, of course, so it's very
     * probably going to be an easy computation
     */
    // we need to be cxx to do that.
    // cxx_mpq_mat p_maximal_order(cxx_mpz_poly const& f, cxx_mpz const& p)
    O = numbertheory_internals::p_maximal_order(f0, ell);
    M = numbertheory_internals::multiplication_table_of_order(O, f0);
    for (auto const & Ie: numbertheory_internals::factorization_of_prime(
             O, f0, ell, cxx_gmp_randstate())) {
        cxx_mpz_mat const & I(Ie.first);
        // int e = Ie.second;
        const cxx_mpz_mat a =
            numbertheory_internals::valuation_helper_for_ideal(M, I, ell);
        auto two = numbertheory_internals::prime_ideal_two_element(O, f0, M, I);

        cxx_mpq_mat theta_q;
        {
            mpq_mat_set_mpz_mat(theta_q, two.second);
            mpq_mat_mul(theta_q, theta_q, O);
        }
        /*
        const std::string uniformizer =
            numbertheory_internals::write_element_as_polynomial(theta_q,
                                                                "alpha");
                                                                */

        // ideals.emplace_back(I, a, theta_q);

        // int v = valuation_of_ideal_at_prime_ideal(M, Id, a, e, ell);

        /*
        fmt::print("# (ell={}, f={}, e={}; ideal<O|{}, {}>);\n",
                this->ell, prime_ideal_inertia_degree(I), e,
                two.first, uniformizer);
                */

        // cxx_mpq_mat jjinv_gen(2, f->deg);
        // mpq_set_ui(mpq_mat_entry(jjinv_gen,0,0),1,1);
        // mpq_set_ui(mpq_mat_entry(jjinv_gen,1,1),1,1);
        // jjinv = ::generate_ideal(O,M,jjinv_gen);
        for (auto & pp: pieces) {
            // fmt::print("considering {}\n", pp.g.print_poly("alpha"));
            cxx_mpq_mat gens(2, f0->deg);
            mpq_set_z(gens(0, 0), ell);
            for (int i = 0; i < f0->deg; i++) {
                mpq_set_z(gens(1, i), mpz_poly_coeff_const(pp.g, i));
            }
            /* I is returned as matrix wrt O and denominator */
            auto I = numbertheory_internals::generate_ideal(O, M, gens);
            const int v = numbertheory_internals::valuation_of_ideal_at_prime_ideal(
                M, I, a, 1, ell);
            if (v == 0)
                continue;
            /* we've found the ideal to which this corresponds.
             */
            ASSERT_ALWAYS(v == 1);
            ASSERT_ALWAYS(pp.a.nrows() == 0);
            ASSERT_ALWAYS(pp.uniformizer.nrows() == 0);
            pp.a = a;
            pp.uniformizer = theta_q;
            // fmt::print("found!\n");
        }
    }

#if 0
    for(auto const & pp : pieces) {
        fmt::print("considering {}\n", pp.g.print_poly("alpha"));
        cxx_mpq_mat gens(2, f0->deg);
        mpq_set_z(gens(0,0), ell);
        for(int i = 0 ; i < f0->deg ; i++) {
            mpq_set_z(gens(1,i), mpz_poly_coeff_const(pp.g, i));
        }
        /* I is returned as matrix wrt O and denominator */
        auto I = generate_ideal(O, M, gens);

        fmt::print("I is 1/{} times:\n", I.second);
        mpz_mat_fprint(stdout, I.first);

        for(auto const & ii : nt(I)) {
            // int v = valuation_of_ideal_at_prime_ideal(M, I, ii.a, 1, ell);

            fmt::print(" --> valuation (through structure) is {}\n", ii);

        }

        for(auto const & a : nt.helpers) {
            int v = valuation_of_ideal_at_prime_ideal(M, I, a, 1, ell);
            fmt::print(" --> valuation (direct call) is {}\n", v);

            mpz_mat_fprint(stdout, a);
        }
    }
#endif
}

void sm_side_info::set_mode(char const * mode_string)
{
    if (mode_string == nullptr || strcmp(mode_string, "default") == 0) {
        mode = SM_MODE_2018;
    } else if (strcmp(mode_string, "2018") == 0) {
        mode = SM_MODE_2018;
    } else if (strcmp(mode_string, "legacy") == 0) {
        mode = SM_MODE_LEGACY_PRE2018;
    } else if (strcmp(mode_string, "2019rev") == 0) {
        mode = SM_MODE_2019REV;
    } else if (strcmp(mode_string, "pseudorandom-combination") == 0) {
        mode = SM_MODE_PSEUDORANDOM_COMBINATION;
        abort(); /* not implemented yet */
    }

    if (mode == SM_MODE_LEGACY_PRE2018) {
        ASSERT_ALWAYS(!matrix);
        matrix = cxx_mpz_mat(f->deg, f->deg);
        compute_change_of_basis_matrix(matrix, f, pieces, ell);
        for (auto & P: pieces)
            P.is_used = true;
    }
}
